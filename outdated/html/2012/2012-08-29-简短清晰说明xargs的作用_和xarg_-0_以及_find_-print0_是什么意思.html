<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>简短清晰说明xargs的作用；和xarg -0 以及 find -print0 是什么意思</title>
    <link href="/css/local.css" rel="stylesheet">
    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-3301463-1']);
    _gaq.push(['_trackPageview']);
   (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
    </script>
    </head>
    <body>
      <h1>简短清晰说明xargs的作用；和xarg -0 以及 find -print0 是什么意思</h1>

<blockquote>
  <p>To better understand this, let’s look at something that won’t work. Say you wanted to delete all markdown files. You might be tempted to try:</p>

  <pre><code>find . -iname "*.md" | rm
</code></pre>

  <p>The first part does what we expect it to do, it finds all files with a markdown extension. However, piping find’s output to rm doesn’t do anything other than display the help message for rm. Why is that? Remember, pipe redirects a program’s output to another program’s input. rm however does not work via standard input. It works via the command-line. In C#, that’s the difference between Console.ReadLine() and using the args[] parameter.</p>

  <p>The solution to this problem is to use a special utility which converts standard input into a command-line. This is what xargs does. Unfortunately, xargs can be quite different from platform to platform, but all we need right now is the simplest thing:</p>

  <pre><code>find . -iname "*.md" | xargs rm
</code></pre>

  <p>If you’ve been following along, you can guess that xargs takes data from the standard input (hence data can be piped to it) and converts that to command-line parameters for whatever program you specify (rm in this case).</p>

  <p>How do you know if a program takes data from standard input vs the command-line? Well, if you look at the help message from grep, you’ll see that it takes its input from [FILE], whereas rm takes it from file. It’s a subtle difference.</p>

  <p>souce: http://openmymind.net/2012/4/13/Piping-Basics</p>
</blockquote>

<p>另外根据man page：</p>

<pre><code>   --arg-file=file
   -a file
          Read items from file instead of standard  input.   If  you  use
          this  option,  stdin  remains  unchanged when commands are run.
          Otherwise, stdin is redirected from /dev/null.

   --null
   -0     Input items are terminated by a null character  instead  of  by
          whitespace, and the quotes and backslash are not special (every
          character is  taken  literally).   Disables  the  end  of  file
          string,  which is treated like any other argument.  Useful when
          input items might contain white space, quote  marks,  or  back‐
          slashes.   The  GNU find -print0 option produces input suitable
          for this mode.
</code></pre>

<p>这里说明那个 -0 (阿拉伯数字0)的意思是，默认xarg根据空格来分割文件名，因此如果前面命令传入的文件名可能是有空格，就会出现错误，这时用 -0 就好了，会忽略空格，反斜杠和引号。同样，要让前面传入的文件名符合要求，可用 gnu find -print0 。</p>


    </body>
    <footer>
    <a href="../">Up    </a>
    <a href="/">Home</a>
    <!-- generated on 2013-01-23 09:55:58 +0800 -->
    </footer>
</html>

