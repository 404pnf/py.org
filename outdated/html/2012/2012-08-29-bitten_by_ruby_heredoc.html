<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>bitten by ruby heredoc</title>
    <link href="/css/local.css" rel="stylesheet">
    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-3301463-1']);
    _gaq.push(['_trackPageview']);
   (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
    </script>
    </head>
    <body>
      <h1>bitten by ruby heredoc</h1>

<h2>s = «eof  will DO interpolation</h2>

<p>irb(main):002:0&gt; s = «eof
irb(main):003:0” #{1+1}
irb(main):004:0” eof
=&gt; “2\n”</p>

<h2>«-‘eof’ will NOT do interpoliation</h2>
<p>irb(main):012:0&gt; s = «-‘eof’
irb(main):013:0’ #{1+1}
irb(main):014:0’ eof
=&gt; “#{1+1}\n”</p>

<h2>’’’ will NOT do interpoliation</h2>
<p>irb(main):019:0&gt; s = ‘’’
irb(main):020:0’ #{1+1}
irb(main):021:0’ ‘’’
=&gt; “\n#{1+1}\n”</p>

<h2>my case: \N</h2>

<p>I have string</p>

<p>1,2,3,4,some letters\Nsupposed to be a newline
0,1,2,3,4,some l\ett\e\ars\Nsupposed to be a newline</p>

<p>I have a function that split the string by ‘\N’</p>

<p>Now, if I use</p>

<p>str = «eof
1,2,3,4,some letters\Nsupposed to be a newline
eof</p>

<p>str.split(‘\N’) </p>

<p>Nothing happens because the str is constructed, the ‘\N’ is replaced with ‘N’. WTF?!  ‘\e’ ‘\a’ are fine.</p>

<pre><code>irb(main):023:0&gt; "\N"
=&gt; "N"	
irb(main):024:0&gt; '\N'
=&gt; "\\N"
</code></pre>

<p>Well, I need the \N !  How do I get it?  </p>

<p>Then I found if I read the strings from a file, the \N is preserved.  That made me think it’s the heredoc does some interpolation.</p>

<p>An hour later, ….  An long and tedious hour!</p>

<p>But I learned, maybe I should use heredoc «-‘eof’ format in most cases!  Just in case!</p>

<h2>details log of my testing in irb</h2>

<p>def ass_generate_hash
   hash = Hash.new{|h,k| h[k]=Hash.new(&amp;h.default_proc) }
   self.each do |line|
     arr = line.split(/,/)</p>

<pre><code> # here, the \N in arr[9] is replaced with N
 # WTF!!!??
 #irb(main):001:0&gt; File.read('test.txt')
 #=&gt; "1111\\N2222\n"
 #irb(main):002:0&gt; File.read('test.txt').split('\N')
 #=&gt; ["1111", "2222\n"]
 #p arr
 #p arr[9]
 # read from file is OK?
 timestamp = arr[1].to_s # starting time is enough for key
 lang = arr[3].to_s.downcase
 # 按说这个格式是严格的，因此可以直接用逗号分割
 # !错误，翻译中也有英文逗号，因此不能直接用逗号分割
 # 因此，应该把index 9 之后的所有元素都算为text才对
 # 需要还原之前的英文逗号，因此先join一下
 if arr.size &gt; 9
   text = arr[9..-1].join(',').to_s 
 else
   text = arr[9].to_s
 end
</code></pre>

<p>=begin
     irb(main):035:0&gt; a = ‘1,2\N3’
     =&gt; “1,2\N3”
     irb(main):036:0&gt; a.split(‘,’)
     =&gt; [“1”, “2\N3”]
     irb(main):037:0&gt; a.split(‘,’)[1]
     =&gt; “2\N3”
     irb(main):038:0&gt; a.split(‘,’)[1].split(/\N/)
     =&gt; [“2\”, “3”]
     irb(main):039:0&gt; a.split(‘,’)[1].split(/\N/)
     =&gt; [“2”, “3”]
     # notice the diffrence o \N, single quotes and double quotes!
     irb(main):033:0&gt; d = “NN\NNN”
     =&gt; “NNNNN”  # we lost \N
     irb(main):034:0&gt; d = ‘NN\NNN’
     =&gt; “NN\NNN” # double back slash 
=end
     p arr[9]
     p text
     # 如果 lang 这个项目是 <em>Default，那么输入的文字是中文和英文在一起的，需要用其它逻辑
     # 比如 Dialogue: 0,0:00:40.58,0:00:45.39,</em>Default,NTP,0000,0000,0000,,那些将都是实的 但在那之前\NAnd that will be mostly real. But at one point somewhere,
     # p lang.downcase
     if lang.downcase == “*default”
       r = text.split(‘\N’)
       # text is an array item, we get the array by split method on a string
       # therefore, if the string contains \N, in the array item, it becomse \N
       #irb(main):044:0&gt; a
       #=&gt; “1,2\N3”
       #irb(main):045:0&gt; a.split(‘,’)
       #=&gt; [“1”, “2\N3”]
       #irb(main):046:0&gt; a.split(‘,’)[1].to_s
       #=&gt; “2\N3”
       # this BITES me!!!
       #irb(main):048:0&gt; a.split(‘,’)[1].split(/\N/)
       #=&gt; [“2”, “3”]
       #irb(main):049:0&gt; a.split(‘,’)[1].split(/\N/)
       #=&gt; [“2\”, “3”]
       #这里使用双引号是错误的，看！！！
       #irb(main):027:0&gt; d = ‘NN\NNN’
       #=&gt; “NN\NNN”
       #irb(main):028:0&gt; d.split(‘\N’)
       #=&gt; [“NN”, “NN”]
       #irb(main):029:0&gt; d.split(“\N”
       #p r #这里如果用split(‘\N’)就无法正常分割，如果用 /\N/ 报unknow regex，但正常工作，不知到为什么
       hash[timestamp][:chs] = r[0]
       hash[timestamp][:eng] = r[1]
     elsif lang.downcase == ‘kak’
       hash[timestamp][:chs] = text.sub(‘\N’, ‘ ‘) # 有些中文翻译的lang竟然是 kak
       # 本身这个kak是留给写翻译组参与翻译人的姓名等信息的不应该写翻译本身
       # oCourse-renamed/微积分重点/1.ass:Dialogue: 1,0:29:04.00,0:29:22.00,kak,,0000,0000,0000,,函数一：距离\N函数二：匀变速的速度
       # 而且竟然也用到了换行符号 
       # 采用这个格式是错误的，应该报告给翻译组
       # 我们在此处理一下
     else
       #p text
       hash[timestamp][lang.to_sym] = text.gsub(‘\N’, ‘ ‘) # 这里的sub没有成功
     end
   end
   hash
 end</p>

    </body>
    <footer>
    <a href="../">Up    </a>
    <a href="/">Home</a>
    <!-- generated on 2013-01-23 09:55:54 +0800 -->
    </footer>
</html>

