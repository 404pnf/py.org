# bitten by ruby heredoc

## s = <<eof  will DO interpolation

irb(main):002:0> s = <<eof
irb(main):003:0" #{1+1}
irb(main):004:0" eof
=> "2\n"


## <<-'eof' will NOT do interpoliation
irb(main):012:0> s = <<-'eof'
irb(main):013:0' #{1+1}
irb(main):014:0' eof
=> "\#{1+1}\n"

## ''' will NOT do interpoliation
irb(main):019:0> s = '''
irb(main):020:0' #{1+1}
irb(main):021:0' '''
=> "\n\#{1+1}\n"

## my case: \N

I have string


1,2,3,4,some letters\Nsupposed to be a newline
0,1,2,3,4,some l\ett\e\ars\Nsupposed to be a newline

I have a function that split the string by '\N'

Now, if I use

str = <<eof
1,2,3,4,some letters\Nsupposed to be a newline
eof

str.split('\N') 

Nothing happens because the str is constructed, the '\N' is replaced with 'N'. WTF?!  '\e' '\a' are fine.

	irb(main):023:0> "\N"
	=> "N"	
	irb(main):024:0> '\N'
	=> "\\N"

Well, I need the \N !  How do I get it?  

Then I found if I read the strings from a file, the \N is preserved.  That made me think it's the heredoc does some interpolation.

An hour later, ....  An long and tedious hour!

But I learned, maybe I should use heredoc <<-'eof' format in most cases!  Just in case!


## details log of my testing in irb

 def ass_generate_hash
   hash = Hash.new{|h,k| h[k]=Hash.new(&h.default_proc) }
   self.each do |line|
     arr = line.split(/,/)
     
     # here, the \N in arr[9] is replaced with N
     # WTF!!!??
     #irb(main):001:0> File.read('test.txt')
     #=> "1111\\N2222\n"
     #irb(main):002:0> File.read('test.txt').split('\N')
     #=> ["1111", "2222\n"]
     #p arr
     #p arr[9]
     # read from file is OK?
     timestamp = arr[1].to_s # starting time is enough for key
     lang = arr[3].to_s.downcase
     # 按说这个格式是严格的，因此可以直接用逗号分割
     # !错误，翻译中也有英文逗号，因此不能直接用逗号分割
     # 因此，应该把index 9 之后的所有元素都算为text才对
     # 需要还原之前的英文逗号，因此先join一下
     if arr.size > 9
       text = arr[9..-1].join(',').to_s 
     else
       text = arr[9].to_s
     end
     
=begin
     irb(main):035:0> a = '1,2\N3'
     => "1,2\\N3"
     irb(main):036:0> a.split(',')
     => ["1", "2\\N3"]
     irb(main):037:0> a.split(',')[1]
     => "2\\N3"
     irb(main):038:0> a.split(',')[1].split(/\N/)
     => ["2\\", "3"]
     irb(main):039:0> a.split(',')[1].split(/\\N/)
     => ["2", "3"]
     # notice the diffrence o \N, single quotes and double quotes!
     irb(main):033:0> d = "NN\NNN"
     => "NNNNN"  # we lost \N
     irb(main):034:0> d = 'NN\NNN'
     => "NN\\NNN" # double back slash 
=end
     p arr[9]
     p text
     # 如果 lang 这个项目是 *Default，那么输入的文字是中文和英文在一起的，需要用其它逻辑
     # 比如 Dialogue: 0,0:00:40.58,0:00:45.39,*Default,NTP,0000,0000,0000,,那些将都是实的 但在那之前\NAnd that will be mostly real. But at one point somewhere,
     # p lang.downcase
     if lang.downcase == "*default"
       r = text.split('\N')
       # text is an array item, we get the array by split method on a string
       # therefore, if the string contains \N, in the array item, it becomse \\N
       #irb(main):044:0> a
       #=> "1,2\\N3"
       #irb(main):045:0> a.split(',')
       #=> ["1", "2\\N3"]
       #irb(main):046:0> a.split(',')[1].to_s
       #=> "2\\N3"
       # this BITES me!!!
       #irb(main):048:0> a.split(',')[1].split(/\\N/)
       #=> ["2", "3"]
       #irb(main):049:0> a.split(',')[1].split(/\N/)
       #=> ["2\\", "3"]
       #这里使用双引号是错误的，看！！！
       #irb(main):027:0> d = 'NN\NNN'
       #=> "NN\\NNN"
       #irb(main):028:0> d.split('\N')
       #=> ["NN", "NN"]
       #irb(main):029:0> d.split("\N"
       #p r #这里如果用split('\N')就无法正常分割，如果用 /\N/ 报unknow regex，但正常工作，不知到为什么
       hash[timestamp][:chs] = r[0]
       hash[timestamp][:eng] = r[1]
     elsif lang.downcase == 'kak'
       hash[timestamp][:chs] = text.sub('\N', ' ') # 有些中文翻译的lang竟然是 kak
       # 本身这个kak是留给写翻译组参与翻译人的姓名等信息的不应该写翻译本身
       # oCourse-renamed/微积分重点/1.ass:Dialogue: 1,0:29:04.00,0:29:22.00,kak,,0000,0000,0000,,函数一：距离\N函数二：匀变速的速度
       # 而且竟然也用到了换行符号 
       # 采用这个格式是错误的，应该报告给翻译组
       # 我们在此处理一下
     else
       #p text
       hash[timestamp][lang.to_sym] = text.gsub('\N', ' ') # 这里的sub没有成功
     end
   end
   hash
 end
